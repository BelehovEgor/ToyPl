# toy pl

## Как запускать
+ передать в аргументы 
	+ путь до исполняемого файла (*.tpl, *.vm)
	+ (опционально) величину n (default 5)
	+ (опционально) путь куда генерируется .vm файл


## Язык ToyPl

### Синтаксис

+ Грамматика для языка ToyPl реализована с помощью antlr
	+ [lexer](/src/ToyPl/ToyPlLanguage/toyPlLexer.g4)
		+ доступные токены для использования
	+ [parser](/src/ToyPl/ToyPlLanguage/toyPlParser.g4)
		+ *var* - определение переменной
		+ *expr* - определение вычислений над типом
		+ *int_op* - операции вычисления
		+ *cond_int_op* - операции сравнения
		+ *cond_bool_op* - операции над bool
		+ *cond* - определение предикатов
		+ *statement* - определение множества операций над типами
		+ *program* - определение программы

#### Example
```
(
    (   
        a := 15
        ;
        (
            b := 1
            ;
            c := 1
        )
    )
    ;
    (
        (
            ( 
                ( (a >= b)? ) 
                ; 
                ( 
                    ( 
                        ( 
                            ( (a % b) = 0 ) ? 
                            ; 
                            (c := b)
                        ) 
                        U 
                        ( 
                            (!( (a % b) = 0 )) ?
                        ) 
                    )
                    ;
                    b := (b + 1)
                ) 
            )*
            ;
            (
                (a % (b - 1)) = 0
            )?
        )
        U
        ( (!(a >= b))? )
    )
)
```

### Семантика

+ Cемантика ядра определяется на алгебре бинарных отношений
	+ Присваивание
	+ Композиция
	+ Объединение
	+ Транзитивное и рефлексивное замыкание

#### Поддерживаемые типы
+ {>= 0} unsigned int mod type {< 2^n^}
+ {a >= 2^n^} x := a <=> x := a % 2^n^

## Язык виртуальной машины

+ Каждая строка имеет строение
    + Идентификатор операции
    + Тип операции
        + *assign* - изменение состояния
        + *fork* - объединение набора состояний
        + *if* - выбор пути исполнения согласно предикату
        + *closure* - транзитивное и рефлексивное замыкание
        + *exit* - выход из любого состояния с ошибкой
        + *empty* - блок, который возвращает входящее состояние
    + Содержимое операции
        + Набор других операций
        + Выражение
        + Предикат
    + Набор следующих операций
        + Может быть пустым
        + Если является последним блоком - программа завершается

#### Example

```
0:assign:a=15:1
1:assign:b=1:2
2:assign:c=1:3
3:fork::4,5
4:closure::6,7
5:if:(! (a >= b)):19,20
6:if:(a >= b):8,9
7:if:((a % (b - 1)) = 0):17,18
8:fork::10,11,12
9:exit::
10:if:((a % b) = 0):13,14
11:if:(! ((a % b) = 0)):15,16
12:assign:b=(b + 1):
13:assign:c=b:
14:exit::
15:empty::
16:exit::
17:empty::
18:exit::
19:empty::
20:exit::
```

## Примеры

+ volume.tpl - вычисление объема параллелепипеда
    + {3<=N<=8 & 0<=a<=(2^N^-1) & 0<=b<=(2^N^-1) & 0<=b<=(2^N^-1)} code { 0<=c<=(2^N^-1) & c = (a * b * c) % 2^N^}
+ fast-times.tpl - вычисление произведения 2 чисел
    + {3<=N<=8 & 0<=a<=(2^N^-1) & 0<=b<=(2^N^-1)} code { 0<=z<=(2^N^-1) & z = (a * b) % 2^N^}
+ mults.tpl - вывод всех множителей числа
    + {3<=N<=8 & 0<=a<=(2^N^-1)} code { 0<=c<=(2^N^-1) & c \<= a & a % c = 0}
+ fibbonachi.tpl - вычисление чисел фиббоначи
    + {3<=N<=8 & 0<=n<=(2^N^-1) & fib(k:int)=if (k=0 V k=1) then 1 else (fib(k-1)+fib(k-2))} code {a=(fib(n)%(2^N^-1))}
+ euclidean.tpl - алгоритм эвклида вычисления НОД **in** (a b), **out** (a ~~b~~)
    + {3<=N<=8 & 0<=n<=(2^N^-1) & eucl(a:int, b:int)=if (a == b) then a else if (a > b) then eucl(a-b, b) else eucl(b-a, a)} code {a=eucl(a, b)}
+ boom.tpl - вычисление булевой фурмулы
    + {3<=N & 0<=p<=1 & 0<=q<=1 & 0<=s<=1 & 0<=t<=1} code {p && !q || s && !t} 
